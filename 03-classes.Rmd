# Classes {#classes}

## Introduction

We begin describing how to create object classes.



## Objects and Classes

Taking the code we've written for tossing a coin, we can generate two series of tosses. The first experiment involves tossing a coin five times, and then computing the proportion of heads:

```{r}
# random seed
set.seed(534)

# five tosses
five <- toss(coin, times = 5)
five

# prop of heads in five
sum(five == "heads") / length(five)
```

The second experiment involves tossing a coin six times and computing the proportion of heads:

```{r}
# six tosses
six <- toss(coin, times = 6)
six

# prop of heads in six
sum(six == "heads") / length(five)
```

The above code works ... except that there is an error; the number of heads in `six` is being divided by 5 instead of 6. R hasn't detected this error: it doesn't know that the division has to be done using `length(six)`.

Wouldn't it be prefarable to have some mechanism that prevented this type of error from happening? Bugs will always be part of any programming activity, but it is better to minimize certain types of errors like the one above.


## S3 Classes

R has two (plus one) object oriented systems, so it can be a bit intimidatingwhen you read and learn about them for the first time. 
The goal of this tutorial is not to make you an expert in all R's OOP systems, but to help you become familiar with the so-called _S3 class_.

__S3__ implements a style of OO programming called generic-function OO. S3 uses a special type of function called a _generic_ function that decides which method to call. Keep in mind that S3 is a very casual system: it does not really have a formal definition of classes.

S3 classes are widely-used, in particular for statistical models in the `"stats"` package. S3 classes are very informal in that there is not a formal definition for an S3 class. Usually, S3 objects are built on top of lists, or atomic vectors with attributes. But you can also turn functions into S3 objects.

Note that in more formal OOP languages, all functions are associated with a class, while in R, only some are.


### Making an object

To make an object an instance of a class, you just take an existing base object and set the `"class"` attribute. You can do that during creation of the object with `structure()`

```{r structure-class}
# object coin via structure()
coin1 <- structure(c("heads", "tails"), class = "coin") 
coin1
```

You can also create an object first, and then specify its class with the function `class()`:

```{r attribute-class}
# object coin via class()
coin2 <- c("heads", "tails")
class(coin2) <- "coin"
coin2
```

As any object in R, you can inspect the class `coin1`, and `coin2` with the `class()` function:

```{r class-example}
class(coin1)

class(coin2)
```

You can also determine if an object inherits from a specific class using `inherits()`

```{r inherits-example}
inherits(coin2, "coin")
```


### Generic and Specific Methods

Having a coin object, we can simulate flipping the coin with our previously defined function `toss()`:

```{r}
toss(coin1, times = 5)
```

The issue with the way `toss()` is defined, is that you can pass it any type of vector (not necessarily of class `"coin"`), and it will still work:

```{r}
toss(c('tic', 'tac', 'toe'))
```


To create a function `toss()` that only works for objects of class `"coin"`, we could add a `stop()` condition that checks if the argument `coin` is of the right class:

```{r}
toss <- function(x, times = 1, prob = NULL) {
  if (class(x) != "coin") {
    stop("\ntoss() requires an object 'coin'")
  }
  sample(x, size = times, replace = TRUE, prob = prob)
}

# ok
toss(coin1)

# bad coin
toss(c('tic', 'tac', 'toe'))
```



## A more robust `"coin"` class

Let's review our class `"coin"`. The way we defined a coin object was like this:

```{r simple-coin}
# object coin
coin1 <- c("heads", "tails")
class(coin1) <- "coin" 
```

While this definition is good to illustrate the concept of an object, its class, and how to define generic methods, it is a very loose-defined class. One could create a `"coin"` out of `c('tic', 'tac', 'toe')`, and then use `toss()` on it:

```{r}
ttt <- c('tic', 'tac', 'toe')
class(ttt) <- "coin"

toss(ttt)
```

We need a more formal definition of a coin. For instance, it makes more sense to require that a coin should only have two sides. In this way, the vector `ttt` would not be a valid coin.

For convenience purposes, we can define a __class constructor__ function to
initialize a `"coin"` object:

```{r}
coin <- function(object = c("heads", "tails")) {
  class(object) <- "coin"
  object
}

# default coin
coin()

# another coin
coin(c("h", "t"))
```


## Improving `"coin"` objects

To implement the requirement that a coin must have two sides, we can check for the length of the input vector:

```{r}
coin <- function(object = c("heads", "tails")) {
  if (length(object) != 2) {
    stop("\n'object' must be of length 2")
  }
  class(object) <- "coin"
  object
}

# US penny
penny <- coin(c("lincoln", "shield"))
penny
```

```{r invalid-coin}
# invalid coin
coin(ttt)
```


Because the `toss()` function simulates flips using `sample()`, we can take advantage of the argument `prob` to specify probabilities for each side of the coin. In this way, we can create _loaded_ coins. 

We can add a `prob` argument to the constructor function. This argument takes a vector of probabilities for each element in `object`, and we pass this vector as an attribute of the coin object. Furthermore, we can set a default `prob = c(0.5, 0.5)`, that is, a _fair_ coin by default:

```{r}
coin <- function(object = c("heads", "tails"), prob = c(0.5, 0.5)) {
  if (length(object) != 2) {
    stop("\n'object' must be of length 2")
  }
  attr(object, "prob") <- prob
  class(object) <- "coin"
  object
}

coin()
```


Once again, we need to check for the validity of `prob`. We basically need to check that `prob` and its elements meet the following requirements:

- must be numeric and of length 2
- probability values must be between 0 and 1
- the sum of these values must add up to 1

Here is one possible function to check the aspects of `prob` listed above: 

```{r check-prob}
check_prob <- function(prob) {
  if (length(prob) != 2 | !is.numeric(prob)) {
    stop("\n'prob' must be a numeric vector of length 2")
  }
  if (any(prob < 0) | any(prob > 1)) {
    stop("\n'prob' values must be between 0 and 1")
  }
  if (sum(prob) != 1) {
    stop("\nelements in 'prob' must add up to 1")
  }
  TRUE
}
```

Note that I'm adding a `TRUE` statement at the end of the function. This is just an auxiliary value to know if the function returns a valid `prob`. Now let's test it with _valid_ and _invalid_ values:

```{r check-good-probs}
# Valid -----------------------
check_prob(c(0.5, 0.5))
check_prob(c(0.1, 0.9))
check_prob(c(1/3, 2/3))
check_prob(c(1/3, 6/9))
```

```{r check-bad-probs}
# Invalid -----------------------
# bad length
check_prob(1)
# bad length
check_prob(c(0.1, 0.2, 0.3))
# negative probability
check_prob(c(-0.2, 0.8))
# what should we do in this case?
check_prob(c(0.33, 0.66))     
```


Here's the improved constructor function `coin()`:

```{r}
coin <- function(object = c("heads", "tails"), prob = c(0.5, 0.5)) {
  if (length(object) != 2) {
    stop("\n'object' must be of length 2")
  }
  check_prob(prob)
  attr(object, "prob") <- prob
  class(object) <- "coin"
  object
}

coin1 <- coin()
coin1
```


## Extending classes

We can extend the class `"coin"` and create a derived class for special types of coins. For instance, say we want to create a class `"quarter"`. One side of the coin refers to George Washington, while the other side refers to John Brown's Fort:

https://en.wikipedia.org/wiki/Quarter_(United_States_coin)

```{r quarter-coin}
quarter1 <- coin(c("washington", "fort")) 
class(quarter1) <- c("quarter", "coin")
quarter1
```

Our coin `quarter1` inherits from `"coin"`:

```{r}
inherits(quarter1, "coin")
```

Likewise, we can create a class for a slightly unbalanced `"dime"`:

```{r dime-coin}
dime1 <- coin(c("roosevelt", "torch"), prob = c(0.48, 0.52))
class(dime1) <- c("dime", "coin")
dime1
```

Here's another coin example, a _peso_, from Mexico (where I grew up). When you flip a _peso_, you have two sides: _aguila_ (eagle) or _sol_ (sun):

```{r peso}
peso <- coin(c("aguila", "sol")) 
class(peso) <- c("peso", "coin")
peso
```
